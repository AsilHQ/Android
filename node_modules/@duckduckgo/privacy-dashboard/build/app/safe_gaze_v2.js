// Copyright 2023 The Kahf Browser Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

const imagesToReplace = [];
const cleanedSavedImagesArray = []

window.safegazeOnDeviceModelHandler = safegazeOnDeviceModelHandler;
window.sendMessage = sendMessage;
window.updateBluredImageOpacity = updateBluredImageOpacity;

async function safegazeOnDeviceModelHandler(shouldBlur, index) {
    if (shouldBlur) {
        imagesToReplace.push(cleanedSavedImagesArray[index]);
        // Check if the batch size (5) is reached, or if it's the last image
        if (imagesToReplace.length % 5 === 0) {
            try {
                //sendMessage("**//analyzedImages");
                await analyzeImages(imagesToReplace.slice(-5)); // Get the last 5 elements
            } catch (error) {
                sendMessage('**//Error in analyzeImages:' + error);
            }
        }
        else if (index === cleanedSavedImagesArray.length - 1) {
            // If it's the last image and we have fewer than 5 images, wait for a certain period
            setTimeout(async () => {
                if (imagesToReplace.length > 0 && index === cleanedSavedImagesArray.length - 1) {
                    try {
                        const startIndex = Math.floor(imagesToReplace.length / 5) * 5;
                        let slice = imagesToReplace.slice(startIndex)
                        //sendMessage("**//analyzedImages/escape " + slice.length);
                        await analyzeImages(slice);
                    } catch (error) {
                        sendMessage('**//Error in analyzeImages:' + error);
                    }
                }
            }, 1000); // Adjust the timeout value as needed (5 seconds in this example)
        } else {
            //sendMessage("**//skipForCount" + imagesToReplace.length);
        }
    } else {
        let element = cleanedSavedImagesArray[index]
        unblurImage(element);
        element.removeAttribute('data-lazysrc');
        element.removeAttribute('srcset');
        element.removeAttribute('data-srcset');
        element.setAttribute('data-replaced', 'true');
    }
};

function sendMessage(message) {
    console.log(message);
    try {
        SafeGazeInterface.sendMessage(message)
    }
    catch {}
}

function removeSourceElementsInPictures() {
    const pictureElements = document.querySelectorAll('picture');

    pictureElements.forEach(picture => {
        const sourceElements = picture.querySelectorAll('source');
        sourceElements.forEach(source => {
            source.remove();
        });
    });
}

function blurImage(image) {
  image.style.filter = `blur(${window.blurIntensity * 10}px)`;
  image.setAttribute('isBlurred', 'true');
}

function unblurImageOnLoad(image) {
  image.onload = () => {
      image.style.filter = 'none';
  };
  image.setAttribute('isBlurred', 'false');
}

//Means that there is no object in image
function unblurImage(image) {
    image.style.filter = 'none';
    image.setAttribute('isBlurred', 'false');
}

function setImageSrc(element, url) {
    const isBackgroundImage = element.getAttribute('hasBackgroundImage') && element.tagName !== "IMG" && element.tagName !== "image";
    if (isBackgroundImage) {
        element.style.backgroundImage = `url(${url})`;
        element.setAttribute('data-replaced', 'true');
        unblurImage(element);
    }
    else {
        element.src = url;
        element.removeAttribute('data-lazysrc');
        element.removeAttribute('srcset');
        element.removeAttribute('data-srcset');
        element.setAttribute('data-replaced', 'true');
        unblurImageOnLoad(element);
        if (element.dataset) {
            element.dataset.src = url;
        }
    }
    sendMessage("replaced"); //Sends message for total blurred imaged count
}


const analyzeImages = async (batch) => {
    batch.forEach(imgElement => {
      imgElement.setAttribute('isSent', 'true');
    });
};

function updateBluredImageOpacity() {
    const blurredElements = document.querySelectorAll('[isBlurred="true"]');
    blurredElements.forEach(element => {
        element.style.filter = `blur(${window.blurIntensity * 20}px)`;
    });
}

async function replaceImagesWithApiResults() {
  const batchSize = 4;
  const minImageSize = 40; // Minimum image size in pixels

  const hasMinRenderedSize = (element) => {
    const rect = element.getBoundingClientRect();
    return rect.width >= minImageSize && rect.height >= minImageSize;
  };

  // Scroll event listener
  const fetchNewImages = async () => {
     removeSourceElementsInPictures();
     const backgroundImages = Array.from(document.querySelectorAll(':not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
           const backgroundImage = img.style.backgroundImage;
           if (backgroundImage) {
               const backgroundImageUrl = backgroundImage.slice(5, -2);
               const hasBackgroundImage = backgroundImage.startsWith("url(");
               if (hasBackgroundImage && img.tagName !== "IMG" && !backgroundImageUrl.includes('.svg')) {
                  blurImage(img);
                  img.setAttribute('hasBackgroundImage', 'true');
                  img.setAttribute('isSent', 'true');
                  img.setAttribute('src', backgroundImageUrl);
                  return true;
               }
           }
           return false;
     });
     const imageElements = Array.from(document.querySelectorAll('img[src]:not([src*="logo"]):not([src*=".svg"]):not([src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
        const src = img.getAttribute('src');
        const alt = img.getAttribute('alt');
        const id = img.getAttribute('id');
        if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
             return false;
        }
        if (src && !src.startsWith('data:image/') && src.length > 0) {
            if (hasMinRenderedSize(img)) {
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
            else {
                return false;
            }
        }
        else if (!src || src.length === 0) {
            if (img.getAttribute("xlink:href")) {
                img.setAttribute('src', img.getAttribute("xlink:href"));
                img.setAttribute('srcAttr', "xlink:href");
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
        }
        blurImage(img);
        return false;
    });

    const lazyImageElements = Array.from(document.querySelectorAll('img[data-src]:not([data-src*="logo"]):not([data-src*=".svg"]):not([data-src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]:not([data-src*="captcha"])')).filter(img => {
        const dataSrc = img.getAttribute('data-src');
        const alt = img.getAttribute('alt');
        const id = img.getAttribute('id');
        if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
             return false;
        }
        if (dataSrc && !dataSrc.startsWith('data:image/') && dataSrc.length > 0) {
            if (hasMinRenderedSize(img)) {
                blurImage(img);
                img.setAttribute('isSent', 'true');
                img.setAttribute('src', dataSrc);
                return true;
            }
            else {
                return false;
            }
        }
        else if (!dataSrc || dataSrc.length === 0) {
            if (img.getAttribute("xlink:href")) {
                img.setAttribute('src', img.getAttribute("xlink:href"));
                img.setAttribute('srcAttr', "xlink:href");
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
        }
        blurImage(img);
        return false;
    });
    const allImages = [...imageElements, ...lazyImageElements, ...backgroundImages];

    if (allImages.length > 0) {
         const analyzePromises = [];

         allImages.forEach(imgElement => {
           var mediaUrl = imgElement.getAttribute('src') || imgElement.getAttribute('data-src');
           var absoluteUrl = new URL(mediaUrl, window.location.origin).href;
           if (absoluteUrl) {
               mediaUrl = absoluteUrl;
           }

            const analyzePromise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    imgElement.src = mediaUrl
                    sendMessage("coreML/-/" + imgElement.src + "/-/" + cleanedSavedImagesArray.length);
                    cleanedSavedImagesArray.push(imgElement)
                    resolve('');
                }, 200);
            });

           analyzePromises.push(analyzePromise);
         })

         await Promise.all(analyzePromises)
        }
  };
  window.addEventListener('load', function() { fetchNewImages(); });
  window.addEventListener('scroll', fetchNewImages);
  window.addEventListener('unload', sendMessage("page_refresh"))
  window.addEventListener('beforeunload', function () {
        // Reset the arrays when the page is about to unload
        imagesToReplace.length = 0;
        cleanedSavedImagesArray.length = 0;
  });
}

replaceImagesWithApiResults();