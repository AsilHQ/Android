// Copyright 2023 The Kahf Browser Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

const onProcessImageMap = new Map();
var imageCount = 0;
const imagesToReplace = []

window.safegazeOnDeviceModelHandler = safegazeOnDeviceModelHandler;
window.updateBluredImageOpacity = updateBluredImageOpacity;

async function safegazeOnDeviceModelHandler(shouldBlur, uid, quotaExceeded) {
    const imgElement = onProcessImageMap.get(uid);
    onProcessImageMap.delete(uid);
    if (!imgElement) {
        return;
    }
    imageCount++;
    if (shouldBlur) {
        imgElement.setAttribute('isSent', 'true');
        
        if (quotaExceeded) { 
            blurImage(imgElement);
        } else {
            imagesToReplace.push(imgElement);
            if (imagesToReplace.length % 5 === 0) {
                analyzeImages(imagesToReplace.splice(0, 5));
            }
        }
            
        // upon hover or long press, we will unblur the image momentarily
        imgElement.onmouseenter = () => {
            unblurImage(imgElement);
        };
        imgElement.onmouseleave = () => {
            blurImage(imgElement, quotaExceeded);
        }
        
    } else {
        unblurImage(imgElement);
    }
};
function handleDoubleTap(imgElement) {
    let lastTap = 0;
    let touchStartY = 0;
    const doubleTapDelay = 300; // maximum delay between taps to be considered a double tap
    const scrollThreshold = 10; // pixels of vertical movement to be considered a scroll attempt

    function handleTouchStart(e) {
        if (imgElement.getAttribute('isBlurred') === 'true') {
            touchStartY = e.touches[0].clientY;
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < doubleTapDelay && tapLength > 0) {
                // Double tap detected
                e.preventDefault();
                unblurImage(imgElement);
            }
            lastTap = currentTime;
        }
    }

    function handleTouchMove(e) {
        if (imgElement.getAttribute('isBlurred') === 'true') {
            const touchMoveY = e.touches[0].clientY;
            const verticalDistance = Math.abs(touchMoveY - touchStartY);
            if (verticalDistance > scrollThreshold) {
                // User is attempting to scroll, so we don't interfere
                lastTap = 0; // Reset lastTap to prevent accidental double-tap detection
            }
        }
    }

    function handleTouchEnd(e) {
        if (imgElement.getAttribute('isBlurred') === 'true') {
            // Only prevent default if it wasn't a scroll attempt
            if (Math.abs(e.changedTouches[0].clientY - touchStartY) <= scrollThreshold) {
                e.preventDefault();
            }
        }
    }

    imgElement.addEventListener('touchstart', handleTouchStart);
    imgElement.addEventListener('touchmove', handleTouchMove, { passive: true });
    imgElement.addEventListener('touchend', handleTouchEnd);
}

function blurImage(image) {
    const blurMin = 2;
    const blurMax = 8;
    const brightnessMin = 200;
    const brightnessMax = 800;

    // Calculate blur value between 2px and 8px
    const blurValue = blurMin + (window.blurIntensity * (blurMax - blurMin));

    // Calculate brightness value between 200% and 800%
    const brightnessValue = brightnessMin + (window.blurIntensity * (brightnessMax - brightnessMin));

    // Apply the calculated filter values to the image
    image.style.filter = `blur(${blurValue}px) grayscale(100%) contrast(500%) brightness(${brightnessValue}%)`;
    image.setAttribute('isBlurred', 'true');
}

function unblurImageOnLoad(image) {
    image.onload = () => {
        image.style.filter = 'none';
    };
    image.setAttribute('isBlurred', 'false');
}

//Means that there is no object in image
function unblurImage(image) {
    image.style.filter = 'none';
    image.setAttribute('isBlurred', 'false');
}

function updateBluredImageOpacity() {
    const blurredElements = document.querySelectorAll('[isBlurred="true"]');
    blurredElements.forEach(element => {
        blurImage(element);
    });
}

async function getImageElements() {
    try { 
    const minImageSize = 45; // Minimum image size in pixels

    const hasMinRenderedSize = (element) => {
        const rect = element.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return "not rendered yet";
        return (rect.width >= minImageSize && rect.height >= minImageSize)
    };

    const processImage = (htmlElement, src, type="image", srcChanged = false, skipCheck = false) => {
        if (htmlElement.getAttribute('isSent') === type && !srcChanged) return;
        // we need to check the image size, but for that we need to make sure the image
        // has been loaded. If it has not been loaded, we need to wait for it to load
        if (skipCheck || typeof htmlElement.complete !== 'undefined') {
            if (htmlElement.complete) {
                if (!hasMinRenderedSize(htmlElement)) return;
            } else { 
                const prevImgLoad = htmlElement.onload // Save the previous onload function
                htmlElement.onload = () => {
                    if (hasMinRenderedSize(htmlElement)) {
                        processImage(htmlElement, htmlElement.src, false, true);
                    }
                    return prevImgLoad ? prevImgLoad() : null;
                }
                return;
            }
        } else {
            if (hasMinRenderedSize(htmlElement) === false) return; // If the element is rendered but not of minimum size
        }

        blurImage(htmlElement);
        // Handle long press for mobile
        handleDoubleTap(htmlElement);

        const srcEdited = src?.startsWith('://') ? 'https:' + src 
        : src?.startsWith('data:') ? src
        : src;

        const uid = Math.random().toString(36).substr(2, 9);
        sendMessage("coreML/-/" + srcEdited + "/-/" + uid);
        htmlElement.setAttribute('isSent', type);
        htmlElement.ourSrc = srcEdited;
        htmlElement.ourType = type;
        onProcessImageMap.set(uid, htmlElement);
    }

    const observeElement = (el, srcChanged=false) => {
        try {
            if (!el.getAttribute) return;
            if (el.getAttribute('isObserved') && !srcChanged) return; 
            el.setAttribute('isObserved', 'true');

            let src = el.src
            const srcChecker = /url\(\s*?['"]?\s*?(\S+?)\s*?["']?\s*?\)/i
            let bgImage = window.getComputedStyle(el, null).getPropertyValue('background-image')
            let match = bgImage.match(srcChecker);
            // let xlink = el.getAttribute('xlink:href');
            
            if (/^img$/i.test(el.tagName)) { // to handle img tags
                if (el.src?.length > 0) {
                    processImage(el, src, "image", srcChanged);
                } 
            } 
            // SVG images are not supported for now
            // else if (xlink) { // to handle svg images
            //         src = xlink;
            //         processImage(el, src, "svg");
            // }
            else if (match) { // to handle background images
                src = match[1];
                processImage(el, src,"backgroundImage");
            }
        } catch (e) {
            console.log(e);
        }

    }
    
    const fetchNewImages = (mutations) => {
        mutations.forEach(mutation => {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {

                    observeElement(node);
                    // Process all child elements
                    if (!node.getElementsByTagName) return;
                    const allElements = node.getElementsByTagName('*');
                    for (let i = 0; i < allElements.length; i++) {
                        observeElement(allElements[i]);
                    }
                });
            } else if (mutation.type === 'attributes') {
                const el = mutation.target;
                observeElement(el, mutation.attributeName === 'src' && !el.getAttribute("data-replaced"));
            }
        });
    }

            
    const observer = new MutationObserver(fetchNewImages)
    observer.observe(document, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['src']
    });

    // Process initial images
    fetchNewImages([{type: 'childList', addedNodes: [document.body]}]);

    window.addEventListener('unload', sendMessage("page_refresh"))
} catch (e) {
    console.log(e);
}
}


getImageElements();


const analyzeImages = async (batch) => {
    const requestBody = {
     media: batch.map(imgElement => {
           return {
             media_url: imgElement.ourSrc,
             media_type: imgElement.ourType,
             has_attachment: false,
             srcAttr: imgElement.ourSrc,
           };
         })
    };
    
    try {
      // Mark the URLs of all images in the current batch as sent in requests
      batch.forEach(imgElement => {
        imgElement.setAttribute('isSent', 'true');
      });
      
      // Send the request to the API.
      //sendMessage("**Request sent batchCount -> " + batch.length);
      const response = await fetch('https://api.safegaze.com/api/v1/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
      });
      
      // Check if response status is ok
      if (!response.ok) {
        //sendMessage('**Response fail -> HTTP error, status = ' + response.status + "->" + JSON.stringify(requestBody));
        return;
      }
      else {
        //sendMessage("**Response success")
      }
      
      // Extract the response data from the response.
      const responseBody = await response.json();
      if (responseBody.media.length === 0) {
          sendMessage('Empty response');
      }
      else {
          if (responseBody.success) {
            batch.forEach((element, index) => {
                  const correspondingMedia = responseBody.media.find(media => element.src === media.original_media_url || element.src.includes(media.original_media_url));
                  if (correspondingMedia) {
                      if (correspondingMedia.success) {
                          setImageSrc(element, correspondingMedia.processed_media_url);
                        }
                        else {
                          unblurImage(element);
                      }
                  }
            });
          } else {
            sendMessage('API request failed:' + responseBody.errors);
          }
      }
    } catch (error) {
        sendMessage('Error occurred during API request:' + error);
    }
  };

  function setImageSrc(element, url) {
    const isBackgroundImage = element.tagName !== 'IMG';
    if (isBackgroundImage) {
        element.style.backgroundImage = `url(${url})`;
        element.setAttribute('data-replaced', 'true');
        unblurImage(element);
    }
    else {
        element.src = url;
        element.setAttribute('data-replaced', 'true');
        unblurImageOnLoad(element);
        if (element.dataset) {
            element.dataset.src = url;
        }
    }
}