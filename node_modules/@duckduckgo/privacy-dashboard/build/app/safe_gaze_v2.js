// Copyright 2023 The Kahf Browser Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

const imagesToReplace = [];
const cleanedSavedImagesArray = []


window.sendMessage = sendMessage;
window.updateBluredImageOpacity = updateBluredImageOpacity;
const nsfwjs = window.nsfwjs;

function sendMessage(message) {
    console.log(message);
    try {
        SafeGazeInterface.sendMessage(message)
    }
    catch {}
}

function removeSourceElementsInPictures() {
    const pictureElements = document.querySelectorAll('picture');

    pictureElements.forEach(picture => {
        const sourceElements = picture.querySelectorAll('source');
        sourceElements.forEach(source => {
            source.remove();
        });
    });
}

function blurImage(image) {
  image.style.filter = `blur(${window.blurIntensity * 10}px)`;
  image.setAttribute('isBlurred', 'true');
}

function unblurImageOnLoad(image) {
  image.onload = () => {
      image.style.filter = 'none';
  };
  image.setAttribute('isBlurred', 'false');
}

//Means that there is no object in image
function unblurImage(image) {
    image.style.filter = 'none';
    image.setAttribute('isBlurred', 'false');
}

function setImageSrc(element, url) {
    const isBackgroundImage = element.getAttribute('hasBackgroundImage') && element.tagName !== "IMG" && element.tagName !== "image";
    if (isBackgroundImage) {
        element.style.backgroundImage = `url(${url})`;
        element.setAttribute('data-replaced', 'true');
        unblurImage(element);
    }
    else {
        element.src = url;
        element.removeAttribute('data-lazysrc');
        element.removeAttribute('srcset');
        element.removeAttribute('data-srcset');
        element.setAttribute('data-replaced', 'true');
        unblurImageOnLoad(element);
        if (element.dataset) {
            element.dataset.src = url;
        }
    }
    sendMessage("replaced"); //Sends message for total blurred imaged count
}


const analyzeImages = async (batch) => {
  const requestBody = {
   media: batch.map(imgElement => {
         return {
           media_url: imgElement.getAttribute('src'),
           media_type: imgElement.getAttribute('hasBackgroundImage') && imgElement.tagName !== "IMG" && imgElement.tagName !== "image" ? "backgroundImage" : "image",
           has_attachment: false,
           srcAttr: imgElement.getAttribute('srcAttr')
         };
       })
  };
  
  try {
    // Mark the URLs of all images in the current batch as sent in requests
    batch.forEach(imgElement => {
      imgElement.setAttribute('isSent', 'true');
    });
    
    // Send the request to the API.
    //sendMessage("**Request sent batchCount -> " + batch.length);
    const response = await fetch('https://api.safegaze.com/api/v1/analyze', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody)
    });
    
    // Check if response status is ok
    if (!response.ok) {
      //sendMessage('**Response fail -> HTTP error, status = ' + response.status + "->" + JSON.stringify(requestBody));
      return;
    }
    else {
      //sendMessage("**Response success")
    }
    
    // Extract the response data from the response.
    const responseBody = await response.json();
    if (responseBody.media.length === 0) {
        sendMessage('Empty response');
    }
    else {
        if (responseBody.success) {
          batch.forEach((element, index) => {
                const correspondingMedia = responseBody.media.find(media => element.src === media.original_media_url || element.src.includes(media.original_media_url));
                if (correspondingMedia) {
                    if (correspondingMedia.success) {
                        setImageSrc(element, correspondingMedia.processed_media_url);
                    }
                    else {
                        unblurImage(element);
                    }
                }
          });
        } else {
          sendMessage('API request failed:' + responseBody.errors);
        }
    }
  } catch (error) {
      sendMessage('Error occurred during API request:' + error);
  }
};

function updateBluredImageOpacity() {
    const blurredElements = document.querySelectorAll('[isBlurred="true"]');
    blurredElements.forEach(element => {
        element.style.filter = `blur(${window.blurIntensity * 20}px)`;
    });
}

async function replaceImagesWithApiResults() {
  const batchSize = 4;
  const minImageSize = 40; // Minimum image size in pixels
  
  const hasMinRenderedSize = (element) => {
    const rect = element.getBoundingClientRect();
    return rect.width >= minImageSize && rect.height >= minImageSize;
  };
  
  // Scroll event listener
  const fetchNewImages = async () => {
     removeSourceElementsInPictures();
     const backgroundImages = Array.from(document.querySelectorAll(':not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
           const backgroundImage = img.style.backgroundImage;
           if (backgroundImage) {
               const backgroundImageUrl = backgroundImage.slice(5, -2);
               const hasBackgroundImage = backgroundImage.startsWith("url(");
               if (hasBackgroundImage && img.tagName !== "IMG" && !backgroundImageUrl.includes('.svg')) {
                  blurImage(img);
                  img.setAttribute('hasBackgroundImage', 'true');
                  img.setAttribute('isSent', 'true');
                  img.setAttribute('src', backgroundImageUrl);
                  return true;
               }
           }
           return false;
     });
     const imageElements = Array.from(document.querySelectorAll('img[src]:not([src*="logo"]):not([src*=".svg"]):not([src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
        const src = img.getAttribute('src');
        const alt = img.getAttribute('alt');
        const id = img.getAttribute('id');
        if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
             return false;
        }
        if (src && !src.startsWith('data:image/') && src.length > 0) {
            if (hasMinRenderedSize(img)) {
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
            else {
                return false;
            }
        }
        else if (!src || src.length === 0) {
            if (img.getAttribute("xlink:href")) {
                img.setAttribute('src', img.getAttribute("xlink:href"));
                img.setAttribute('srcAttr', "xlink:href");
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
        }
        blurImage(img);
        return false;
    });
      
    const lazyImageElements = Array.from(document.querySelectorAll('img[data-src]:not([data-src*="logo"]):not([data-src*=".svg"]):not([data-src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]:not([data-src*="captcha"])')).filter(img => {
        const dataSrc = img.getAttribute('data-src');
        const alt = img.getAttribute('alt');
        const id = img.getAttribute('id');
        if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
             return false;
        }
        if (dataSrc && !dataSrc.startsWith('data:image/') && dataSrc.length > 0) {
            if (hasMinRenderedSize(img)) {
                blurImage(img);
                img.setAttribute('isSent', 'true');
                img.setAttribute('src', dataSrc);
                return true;
            }
            else {
                return false;
            }
        }
        else if (!dataSrc || dataSrc.length === 0) {
            if (img.getAttribute("xlink:href")) {
                img.setAttribute('src', img.getAttribute("xlink:href"));
                img.setAttribute('srcAttr', "xlink:href");
                blurImage(img);
                img.setAttribute('isSent', 'true');
                return true;
            }
        }
        blurImage(img);
        return false;
    });
    const allImages = [...imageElements, ...lazyImageElements, ...backgroundImages];

    if (allImages.length > 0) {
         const analyzePromises = [];

         for (let i = 0; i < allImages.length; i++) {
           const imgElement = allImages[i];
           imgElement.crossOrigin = 'anonymous';

           let model = await nsfwjs.load();
           let alreadyClassified = imgElement.hasAttribute('classified')

           if (!alreadyClassified) {
                var mediaUrl = imgElement.getAttribute('src') || imgElement.getAttribute('data-src');
                const predictions = await model.classify(imgElement);
                predictions.sort((a, b) => {
                    const classNameA = a.className.toLowerCase();
                    const classNameB = b.className.toLowerCase();

                    if (classNameA < classNameB) {
                        return -1;
                    }
                    if (classNameA > classNameB) {
                        return 1;
                    }
                    return 0;
                });

                let drawing = predictions[0].probability * 100;
                // let hentai = predictions[1].probability * 100;
                let neutral = predictions[2].probability * 100;
                let porn = predictions[3].probability * 100;
                let sex = predictions[4].probability * 100;
                // console.log(`mLog neutral ${drawing + neutral} ${(drawing + neutral) < 10.0}`)

                 if ((drawing + neutral) < 50.0) { // probability of being explicit content is 50%
                   blurImage(imgElement)
                   console.log(`mLog sexy: ${sex} porn: ${porn} ${mediaUrl}`)
                 } else {
                   unblurImage(imgElement)
                   console.log(`mLog Marked as safe ${mediaUrl}`);
                 }
                imgElement.setAttribute('classified', 'true')
           }

           const analyzePromise = Promise(r => { r(0); })
           analyzePromises.push(analyzePromise);
         }

         await Promise.all(analyzePromises)
        }
  };
  window.addEventListener('load', function() { fetchNewImages(); });
  window.addEventListener('scroll', fetchNewImages);
  window.addEventListener('unload', sendMessage("page_refresh"))
  window.addEventListener('beforeunload', function () {
        // Reset the arrays when the page is about to unload
        imagesToReplace.length = 0;
        cleanedSavedImagesArray.length = 0;
  });
}

replaceImagesWithApiResults();