function removeSourceElementsInPictures() {
    try {
        const pictureElements = document.querySelectorAll('picture');

        pictureElements.forEach(picture => {
            const sourceElements = picture.querySelectorAll('source');
            sourceElements.forEach(source => {
                source.remove();
            });
        });

        console.log('removeSourceElementsInPictures called');
    } catch (error) {
        console.error('Error in removeSourceElementsInPictures:', error);
    }
}

function blurImage(image) {
    try {
        console.log('blurImage called');
        image.style.filter = 'blur(10px)';
    } catch (error) {
        console.error('Error in blurImage:', error);
    }
}

function unblurImageOnLoad(image) {
    try {
        console.log('unblurImageOnLoad called');
        image.onload = () => {
            image.style.filter = 'none';
        };
    } catch (error) {
        console.error('Error in unblurImageOnLoad:', error);
    }
}

function unblurImage(image) {
    try {
        console.log('unblurImage called');
        image.style.filter = 'none';
    } catch (error) {
        console.error('Error in unblurImage:', error);
    }
}

function setImageSrc(element, url) {
    try {
        console.log('setImageSrc called');
        const isBackgroundImage = element.getAttribute('hasBackgroundImage') && element.tagName !== "IMG" && element.tagName !== "image";
        if (isBackgroundImage) {
            element.style.backgroundImage = `url(${url})`;
            element.setAttribute('data-replaced', 'true');
            unblurImage(element);
        } else {
            element.src = url;
            element.removeAttribute('data-lazysrc');
            element.removeAttribute('srcset');
            element.removeAttribute('data-srcset');
            element.setAttribute('data-replaced', 'true');
            unblurImageOnLoad(element);
            if (element.dataset) {
                element.dataset.src = url;
            }
        }
    } catch (error) {
        console.error('Error in setImageSrc:', error);
    }
}

async function replaceImagesWithApiResults(apiUrl = 'https://api.safegaze.com/api/v1/analyze') {
    try {
        console.log('replaceImagesWithApiResults called');
        const batchSize = 4;
        const minImageSize = 40; // Minimum image size in pixels

        const hasMinRenderedSize = (element) => {
            try {
                const rect = element.getBoundingClientRect();
                return rect.width >= minImageSize && rect.height >= minImageSize;
            } catch (error) {
                console.error('Error in hasMinRenderedSize:', error);
                return false;
            }
        };

        const replaceImages = async (batch) => {
            try {
                console.log('replaceImages called');
                // Create the request body.
                const requestBody = {
                    media: batch.map(imgElement => {
                        return {
                            media_url: imgElement.getAttribute('src'),
                            media_type: imgElement.getAttribute('hasBackgroundImage') && imgElement.tagName !== "IMG" && imgElement.tagName !== "image" ? "backgroundImage" : "image",
                            has_attachment: false,
                            srcAttr: imgElement.getAttribute('srcAttr')
                        };
                    })
                };

                // Mark the URLs of all images in the current batch as sent in requests
                batch.forEach(imgElement => {
                    imgElement.setAttribute('isSent', 'true');
                });

                // Send the request to the API.
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                // Check if response status is ok
                if (!response.ok) {
                    console.error('API request failed:', response.status, response.statusText);
                    return;
                }

                // Extract the response data from the response.
                const responseBody = await response.json();
                if (responseBody.media.length === 0) {
                    console.log('No media in the response body');
                } else {
                    if (responseBody.success) {
                        batch.forEach((element, index) => {
                            const correspondingMedia = responseBody.media.find(media => element.src === media.original_media_url || element.src.includes(media.original_media_url));
                            if (correspondingMedia) {
                                if (correspondingMedia.success) {
                                    setImageSrc(element, correspondingMedia.processed_media_url);
                                } else {
                                    unblurImage(element);
                                }
                            }
                        });
                    } else {
                        console.error('API request failed:', responseBody.errors);
                    }
                }
            } catch (error) {
                console.error('Error in replaceImages:', error);
            }
        };

        // Scroll event listener
        const fetchNewImages = async () => {
            try {
                console.log('Before removeSourceElementsInPictures');
                removeSourceElementsInPictures();
                console.log('After removeSourceElementsInPictures');

                const backgroundImages = Array.from(document.querySelectorAll(':not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
                    const backgroundImage = img.style.backgroundImage;
                    if (backgroundImage) {
                        const backgroundImageUrl = backgroundImage.slice(5, -2);
                        const hasBackgroundImage = backgroundImage.startsWith("url(");
                        if (hasBackgroundImage && img.tagName !== "IMG" && !backgroundImageUrl.includes('.svg')) {
                            blurImage(img);
                            img.setAttribute('hasBackgroundImage', 'true');
                            img.setAttribute('isSent', 'true');
                            img.setAttribute('src', backgroundImageUrl);
                            return true;
                        }
                    }
                    return false;
                });

                const imageElements = Array.from(document.querySelectorAll('img[src]:not([src*="logo"]):not([src*=".svg"]):not([src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]):not([src*="captcha"])')).filter(img => {
                    const src = img.getAttribute('src');
                    const alt = img.getAttribute('alt');
                    const id = img.getAttribute('id');
                    if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
                        return false;
                    }
                    if (src && !src.startsWith('data:image/') && src.length > 0) {
                        if (hasMinRenderedSize(img)) {
                            blurImage(img);
                            img.setAttribute('isSent', 'true');
                            return true;
                        } else {
                            return false;
                        }
                    } else if (!src || src.length === 0) {
                        if (img.getAttribute("xlink:href")) {
                            img.setAttribute('src', img.getAttribute("xlink:href"));
                            img.setAttribute('srcAttr', "xlink:href");
                            blurImage(img);
                            img.setAttribute('isSent', 'true');
                            return true;
                        }
                    }
                    blurImage(img);
                    return false;
                });

                const lazyImageElements = Array.from(document.querySelectorAll('img[data-src]:not([data-src*="logo"]):not([data-src*=".svg"]):not([data-src*="no-image"]):not([isSent="true"]):not([data-replaced="true"]):not([alt="logo"]:not([data-src*="captcha"])')).filter(img => {
                    const dataSrc = img.getAttribute('data-src');
                    const alt = img.getAttribute('alt');
                    const id = img.getAttribute('id');
                    if (img.parentElement.classList.contains('captcha') || (id && id.includes('captcha'))) {
                        return false;
                    }
                    if (dataSrc && !dataSrc.startsWith('data:image/') && dataSrc.length > 0) {
                        if (hasMinRenderedSize(img)) {
                            blurImage(img);
                            img.setAttribute('isSent', 'true');
                            img.setAttribute('src', dataSrc);
                            return true;
                        } else {
                            return false;
                        }
                    } else if (!dataSrc || dataSrc.length === 0) {
                        if (img.getAttribute("xlink:href")) {
                            img.setAttribute('src', img.getAttribute("xlink:href"));
                            img.setAttribute('srcAttr', "xlink:href");
                            blurImage(img);
                            img.setAttribute('isSent', 'true');
                            return true;
                        }
                    }
                    blurImage(img);
                    return false;
                });

                const allImages = [...imageElements, ...lazyImageElements, ...backgroundImages];

                if (allImages.length > 0) {
                    const cleanedSavedImagesArray = [];
                    const analyzePromises = [];

                    allImages.forEach(imgElement => {
                        try {
                            var mediaUrl = imgElement.getAttribute('src') || imgElement.getAttribute('data-src');
                            var absoluteUrl = new URL(mediaUrl, window.location.origin).href;
                            if (absoluteUrl) {
                                mediaUrl = absoluteUrl;
                            }

                            let analyzer = new RemoteAnalyzer({ mediaUrl });
                            const analyzePromise = analyzer.analyze().then((result) => {
                                if (!result.shouldMask) {
                                    imgElement.src = mediaUrl;
                                    cleanedSavedImagesArray.push(imgElement);
                                } else {
                                    setImageSrc(imgElement, result.maskedUrl);
                                }
                            }).catch((err) => {
                                console.error('Error in analyzePromise:', err);
                            });

                            analyzePromises.push(analyzePromise);
                        } catch (error) {
                            console.error('Error in forEach loop:', error);
                        }
                    });

                    await Promise.all(analyzePromises);

                    const newBatches = [];

                    for (let i = 0; i < cleanedSavedImagesArray.length; i += batchSize) {
                        newBatches.push(cleanedSavedImagesArray.slice(i, i + batchSize));
                    }

                    for (const batch of newBatches) {
                        try {
                            // Filter out images that have already been replaced or sent in previous requests
                            const imagesToReplace = batch.filter(imgElement => {
                                const srcValue = imgElement.getAttribute('src');
                                return !imgElement.hasAttribute('data-replaced') && !srcValue.startsWith('data:image/');
                            });

                            if (imagesToReplace.length > 0) {
                                await replaceImages(imagesToReplace);
                            }
                        } catch (error) {
                            console.error('Error in newBatches loop:', error);
                        }
                    }
                }
            } catch (error) {
                console.error('Error in fetchNewImages:', error);
            }
        };

        fetchNewImages();
        window.addEventListener('scroll', fetchNewImages);
    } catch (error) {
        console.error('Error in replaceImagesWithApiResults:', error);
    }
}

class RemoteAnalyzer {
    constructor(data) {
        this.data = data;
    }

    analyze = async () => {
        try {
            console.log('analyze called');
            let relativeFilePath = this.relativeFilePath(this.data.mediaUrl);
            if (await this.urlExists(relativeFilePath)) {
                return {
                    shouldMask: true,
                    maskedUrl: relativeFilePath,
                };
            }
        } catch (error) {
            console.error('Error in analyze:', error);
        }

        return {
            shouldMask: false,
            maskedUrl: ""
        };
    };

    urlExists = async (url) => {
        try {
            console.log('urlExists called');
            const response = await fetch(url, {
                method: "GET",
                cache: "no-cache"
            });
            return response.ok;
        } catch (error) {
            console.error('Error in urlExists:', error);
            return false;
        }
    };

    relativeFilePath = (originalMediaUrl) => {
        try {
            console.log('relativeFilePath called');
            let url = decodeURIComponent(originalMediaUrl);
            let urlParts = url.split("?");

            // Handling protocol stripped URL
            let protocolStrippedUrl = urlParts[0]
                .replace(/http:\/\//, "")
                .replace(/https:\/\//, "")
                .replace(/--/g, "__")
                .replace(/%/g, "_");

            // Handling query parameters
            let queryParams =
                urlParts[1] !== undefined
                    ? urlParts[1].replace(/,/g, "_").replace(/=/g, "_").replace(/&/g, "/")
                    : "";

            let relativeFolder = protocolStrippedUrl.split("/").slice(0, -1).join("/");
            if (queryParams.length) {
                relativeFolder = `${relativeFolder}/${queryParams}`;
            }

            // Handling file and extension
            let filenameWithExtension = protocolStrippedUrl.split("/").pop();
            let filenameParts = filenameWithExtension.split(".");
            let filename, extension;
            if (filenameParts.length >= 2) {
                filename = filenameParts.slice(0, -1).join(".");
                extension = filenameParts.pop();
            } else {
                filename = filenameParts[0].length ? filenameParts[0] : "image";
                extension = "jpg";
            }

            return `https://cdn.safegaze.com/annotated_image/${relativeFolder}/${filename}.${extension}`;
        } catch (error) {
            console.error('Error in relativeFilePath:', error);
            return "";
        }
    };
}

replaceImagesWithApiResults();
